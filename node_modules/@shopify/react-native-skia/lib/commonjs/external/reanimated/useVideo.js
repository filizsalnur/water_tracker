"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useVideo = void 0;
var _reactNativeReanimated = require("react-native-reanimated");
var _react = require("react");
var _Skia = require("../../skia/Skia");
var _Platform = require("../../Platform");
var _ReanimatedProxy = _interopRequireDefault(require("./ReanimatedProxy"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const defaultOptions = {
  playbackSpeed: 1,
  looping: true,
  paused: false
};
const useOption = value => {
  "worklet";

  // TODO: only create defaultValue is needed (via makeMutable)
  const defaultValue = (0, _reactNativeReanimated.useSharedValue)(_ReanimatedProxy.default.isSharedValue(value) ? value.value : value);
  return _ReanimatedProxy.default.isSharedValue(value) ? value : defaultValue;
};
const useVideo = (source, userOptions) => {
  var _userOptions$paused, _userOptions$looping, _userOptions$playback;
  const video = (0, _react.useMemo)(() => source ? _Skia.Skia.Video(source) : null, [source]);
  const isPaused = useOption((_userOptions$paused = userOptions === null || userOptions === void 0 ? void 0 : userOptions.paused) !== null && _userOptions$paused !== void 0 ? _userOptions$paused : defaultOptions.paused);
  const looping = useOption((_userOptions$looping = userOptions === null || userOptions === void 0 ? void 0 : userOptions.looping) !== null && _userOptions$looping !== void 0 ? _userOptions$looping : defaultOptions.looping);
  const playbackSpeed = useOption((_userOptions$playback = userOptions === null || userOptions === void 0 ? void 0 : userOptions.playbackSpeed) !== null && _userOptions$playback !== void 0 ? _userOptions$playback : defaultOptions.playbackSpeed);
  const currentFrame = _ReanimatedProxy.default.useSharedValue(null);
  const lastTimestamp = _ReanimatedProxy.default.useSharedValue(-1);
  const startTimestamp = _ReanimatedProxy.default.useSharedValue(-1);
  const framerate = (0, _react.useMemo)(() => video ? video.framerate() : -1, [video]);
  const duration = (0, _react.useMemo)(() => video ? video.duration() : -1, [video]);
  const frameDuration = (0, _react.useMemo)(() => framerate > 0 ? 1000 / framerate : -1, [framerate]);
  const disposeVideo = (0, _react.useCallback)(() => {
    "worklet";

    video === null || video === void 0 || video.dispose();
  }, [video]);
  _ReanimatedProxy.default.useFrameCallback(frameInfo => {
    if (!video) {
      return;
    }
    if (isPaused.value && lastTimestamp.value !== -1) {
      return;
    }
    const {
      timestamp
    } = frameInfo;

    // Initialize start timestamp
    if (startTimestamp.value === -1) {
      startTimestamp.value = timestamp;
    }

    // Calculate the current time in the video
    const currentTimestamp = timestamp - startTimestamp.value;

    // Handle looping
    if (currentTimestamp > duration && looping.value) {
      video.seek(0);
      startTimestamp.value = timestamp;
    }

    // Update frame only if the elapsed time since last update is greater than the frame duration
    const currentFrameDuration = frameDuration / playbackSpeed.value;
    if (lastTimestamp.value === -1 || timestamp - lastTimestamp.value >= currentFrameDuration) {
      const img = video.nextImage();
      if (img) {
        if (currentFrame.value) {
          currentFrame.value.dispose();
        }
        if (_Platform.Platform.OS === "android") {
          currentFrame.value = img.makeNonTextureImage();
        } else {
          currentFrame.value = img;
        }
      }
      lastTimestamp.value = timestamp;
    }
  });
  (0, _react.useEffect)(() => {
    return () => {
      // TODO: should video simply be a shared value instead?
      (0, _reactNativeReanimated.runOnUI)(disposeVideo)();
    };
  }, [disposeVideo, video]);
  return currentFrame;
};
exports.useVideo = useVideo;
//# sourceMappingURL=useVideo.js.map